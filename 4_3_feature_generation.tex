コードの時系列変化を捉えるため、3.2節で述べたメソッド単位の変更メトリクスとコミット単位の変更メトリクスを生成する。コードの時系列変化を捉えるため、3.2節で述べたメソッド単位の変更メトリクスとコミット単位の変更メトリクスを生成する。

\paragraph{変更メトリクスの計算}
メソッド単位の変更メトリクスとして、コード行数の変化量、トークン数の変化量、循環的複雑度の変化量を算出する。これらは、同一メソッドのバグ混入時とその1つ前のコミットの値の差分として計算される。

コミット単位の変更メトリクスとして、変更されたファイル数（NF）、追加行数の割合（LA/LT）、削除行数の割合（LD/LT）、1ファイル当たりの平均行数（LT/NF）を生成する。これらは、BugHunterデータセットに含まれるコミット情報から計算により導出される。

\paragraph{メソッドの操作タイプのラベル付与}
各メソッドに対して、そのメソッドが追加、変更、削除のいずれの操作を受けたかを示すラベルを付与する。これらの操作タイプは、バグ混入コミットあるいはバグ修正コミットと、その直前のコミットを比較することで判定される。

\begin{itemize}
    \item 追加（Add）
    \begin{itemize}
        \item 直前のコミットには存在せず、当該コミットで新たに追加されたメソッド
    \end{itemize}
    \item 変更（Modify）
    \begin{itemize}
        \item 直前のコミットと当該コミットの両方に存在し、内容が変更されたメソッド
    \end{itemize}
    \item 削除（Delete）
    \begin{itemize}
        \item 直前のコミットには存在したが、当該コミットで削除されたメソッド
    \end{itemize}
\end{itemize}

これらのラベルは、カテゴリカル変数として扱い、One-Hotエンコーディングを用いて数値ベクトルに変換する。

\paragraph{メソッド識別子の処理}
メソッドの完全修飾名（例: org.elasticsearch.index.fielddata.plain.GeoPointDoubleArrayAtomicFieldData\$Empty.<init>()V）は、そのままでは機械学習モデルに入力できないため、トークン分割を行う。

具体的には、以下の手順で処理する。第一に、正規表現を用いてメソッドシグネチャからパッケージ名、クラス名、メソッド名を抽出する。第二に、パッケージ名を.で分割し、各部分をトークンとする。第三に、クラス名を\$で分割し、各部分をキャメルケース分割する。例えば、"GeoPointDoubleArrayAtomicFieldData"は["Geo", "Point", "Double", "Array", "Atomic", "Field", "Data"]に分割される。第四に、メソッド名をスネークケース（\_や-）で分割した後、さらにキャメルケース分割する。ただし、<init>や<clinit>などの特殊なメソッド名は"constructor"というトークンに変換する。第五に、全てのトークンを小文字に変換する。

さらに、"java"、"util"、"get"、"set"などのJava言語における一般的な単語や、最小トークン長（3文字）未満のトークンをストップワードとして除外する。これにより、メソッドやクラスの本質的な意味を表す有用なトークンのみが抽出される。
抽出されたトークンは、語彙辞書を用いて数値インデックスに変換され、さらにベクトル表現に変換される。この処理により、メソッドが属するパッケージやクラスの名前、メソッド名自体が持つ意味的な情報を特徴量として活用できる。