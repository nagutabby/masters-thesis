欠陥予測精度を向上させるため、コード変更を複数の視点から捉える必要がある。本研究では、メソッド単位とコミット単位という2つの構成要素を用いて特徴量を設計する。

この2つの構成要素を用いる理由は、欠陥は局所的な実装ミスとシステム全体の不整合の両方から生じるためである。メソッド単位のメトリクスは前者を、コミット単位のメトリクスは後者を捉える。また、既存研究において、単一の構成要素のメトリクスを用いるだけでは十分な予測精度を得られないことが示されている。異なる構成要素のメトリクスを組み合わせることで、互いの欠点を補完し合うことができる。

\paragraph{メソッド単位の変更メトリクス}
メソッド単位では、個々のメソッドの局所的な変化を捉えるため、直前のコミットからの変化量を特徴量として用いる。本研究では、コード変更の異なる側面を捉えるため、以下の3つのメトリクスを用いる。

\begin{itemize}
    \item コード行数の変化量: 変更の規模を表し、レビュー労力と相関がある。
    \item トークン数の変化量: 意味のあるコード要素（変数名、演算子、キーワードなど）の変化を捉え、空白行やコメントのみの変更と論理的な変更を区別する。
    \item 循環的複雑度の変化量: 制御フローの複雑さの変化を測定し、条件分岐やループの追加による論理構造の変化を捉える。
\end{itemize}

\paragraph{コミット単位の変更メトリクス}
コミット単位では、特定のコミットに関連付いた変更の影響範囲を捉えるため、以下のメトリクスを用いる。

\begin{itemize}
    \item 変更されたファイル数: 変更範囲の広さを表す。複数ファイルにまたがる変更を加えると、モジュール間の整合性確保が困難になり、欠陥混入リスクが高まる。
    \item コードの追加行数: 変更前のコードに対して追加されたコードの行数。新たなコードの導入が既存のコードに影響する場合、特に欠陥が生まれやすい。
    \item コードの削除行数: 変更前のコードから削除されたコードの行数。大規模な削除は、依存関係の破壊につながる可能性がある。
    \item 変更の広がり: 各ファイルの変更行数から算出されるエントロピーを用いて、変更の広がりを定量化する。変更が複数のファイルに分散しているほど値が大きくなり、それに伴ってレビュー労力が増加する。詳しくは3.4節で述べる。
\end{itemize}

メソッド単位とコミット単位のメトリクスで変化量を採用する理由は、欠陥混入リスクが絶対的な変化に比例するためである。一例として、変化率を用いると小規模なメソッドやコミットにおいて極端な値をとる。例えば、10行のメソッドに対して2行追加した場合の変化率は20\%であり、100行のメソッドに対して2行追加した場合の変化率は2\%であるが、この変化率の違いは欠陥混入リスクとは無関係である。

これらのメトリクスを組み合わせることで、変更の規模と複雑さの両方を捉える。

\paragraph{異なる構成要素に基づく特徴量の活用}
メソッド単位のメトリクスが変更の局所的な影響を捉え、コミット単位のメトリクスが変更の全体的な影響を捉えることで、欠陥予測精度が向上する。例えば、あるメソッドの循環的複雑度が大きく増加した場合（メソッド単位）、それが単一ファイルの変更なのか、複数ファイルにまたがる変更の一部なのか（コミット単位）によって、欠陥混入リスクは異なる。異なる構成要素の特徴を考慮することにより、単一の構成要素では捉えられない欠陥の特徴を識別できる。具体的な活用方法については第4章で述べる。