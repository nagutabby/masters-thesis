欠陥予測の精度向上には、コード変更を複数の視点から捉える必要がある。本研究では、メソッド単位とコミット単位という2つの構成要素で特徴量を設計する。

この2つの構成要素を用いる理由は、欠陥は局所的な実装ミスとシステム全体の不整合の両方から生じるためである。メソッド単位のメトリクスは前者を、コミット単位のメトリクスは後者を捉える。また、既存研究において、ファイル単位やクラス単位といった単一の構成要素のメトリクスでは予測精度に限界があることが示されている。異なる構成要素のメトリクスを組み合わせることで、互いの欠点を補完し合うことができる。

\paragraph{メソッド単位の変更メトリクス}
メソッド単位では、個々のメソッドの局所的な変化を捉えるため、直前のコミットからの変化量を特徴量として用いる。本研究では、コード変更の異なる側面を捉えるため、以下の3つのメトリクスを用いる。

\begin{itemize}
    \item コード行数の変化量: 変更の規模を表し、レビュー労力と相関がある。
    \item トークン数の変化量: 意味のあるコード要素（変数名、演算子、キーワードなど）の変化を捉え、空白行やコメントのみの変更と実質的なロジック変更を区別する。
    \item 循環的複雑度の変化量: 制御フローの複雑さの変化を定量化し、条件分岐やループの追加による論理構造の変化を捉える。
\end{itemize}

これらのメトリクスで変化量を採用する理由は、メソッドのスケールが比較的均一であるためである。変化率を用いると小規模メソッドで値が極端になる。例えば、10行のメソッドへの2行追加は変化率20\%、100行のメソッドへの2行追加は変化率2\%となるが、実際のレビュー労力や欠陥リスクは変化率ではなく変化量に比例する。これら3つの指標は互いに独立した側面を捉えるため、組み合わせることでコード変更を多角的に評価できる。

\paragraph{コミット単位の変更メトリクス}
コミット単位では、一つのコミット全体での変更の影響範囲を捉えるため、以下のメトリクスを用いる。

\begin{itemize}
    \item 変更されたファイル数: 変更のつながりを示し、影響範囲の広さを表す。複数ファイルにまたがる変更は、モジュール間の整合性確保が困難になり、欠陥混入リスクが高まる。\cite{nagappan2005}
    \item コードの追加行数: 変更前のコードに対する追加されたコード行数の割合。新規コードの導入は既存コードとの統合において欠陥を生みやすい。
    \item コードの削除行数: 変更前のコードに対する削除されたコード行数の割合。大規模な削除は、依存関係の破壊につながる可能性がある。
    \item 変更の広がり: 各ファイルの変更行数から算出されるエントロピーにより、変更の分散度を定量化する。変更が複数のファイルに分散しているほど値が大きくなり、レビュー労力の増加を反映する。詳しくは3.4節で述べる。
\end{itemize}

コミット単位でも主に変化量（追加・削除行数）を用いるが、変更の広がりについては、情報理論のエントロピーを用いることで、単純な平均値では捉えられない変更の分散度を定量化する。

これらのメトリクスを組み合わせることで、変更の量的側面（追加・削除行数）と構造的側面（ファイル数、変更の分散度）の両方を捉える。

\paragraph{2つの構成要素に基づく特徴量統合}
メソッド単位のメトリクスが局所的な変更の性質を捉え、コミット単位のメトリクスが変更の全体的な影響範囲を捉えることで、欠陥予測の精度が向上する。例えば、あるメソッドの循環的複雑度が大きく増加した場合（メソッド単位）、それが単一ファイルの変更なのか、複数ファイルにまたがる変更の一部なのか（コミット単位）によって、欠陥リスクは異なる。この統合により、単一の構成要素では捉えられない欠陥パターンを識別できる。具体的な統合方法については第4章で述べる。