コードの時系列変化を捉えるため、メソッド単位とコミット単位という異なる粒度での特徴量を設計する。これらは、それぞれミクロ的視点とマクロ的視点からコード変更の特性を捉える。

\paragraph{メソッド単位の変更メトリクス}
メソッド単位では、個々のメソッドがどの程度変更されたかを捉えるため、以下の変化量を特徴量として用いる。

本研究では、コード行数、トークン数、循環的複雑度という3つの側面から変化を捉える。これらを選定した理由は以下の通りである。コード行数は変更の量的規模を捉え、レビュー作業量との相関が高い。トークン数は意味のあるコード要素(変数名、演算子、キーワードなど)の変化を捉え、行数だけでは見落とされる実質的な変更量を補完する。例えば、同じ10行の変更でも、空白行やコメントのみの変更と、複雑なロジックを含む変更では、トークン数が大きく異なる。循環的複雑度は制御フローの複雑さを定量化し、条件分岐やループの追加といった論理構造の変化を捉える。この指標は、他の複雑度メトリクス(例えば、ネスト深度やハルステッド複雑度)と比較して、ソフトウェア欠陥との相関が実証されており、広く採用されている。これら3つの指標は互いに独立した側面を捉えるため、組み合わせることでコード変更を多角的に評価できる。

\begin{itemize}
    \item コード行数の変化量
    \begin{itemize}
        \item 直前のコミットと比較したときのコード行数の増減
    \end{itemize}
    \item トークン数の変化量
    \begin{itemize}
        \item 直前のコミットと比較したときのトークン数の増減
    \end{itemize}
    \item 循環的複雑度の変化量
    \begin{itemize}
        \item 直前のコミットと比較したときの循環的複雑度の増減
    \end{itemize}
\end{itemize}

これらのメトリクスで変化量を採用する理論的根拠は以下の通りである。第一に、メソッドは比較的スケールが均一である。個々のメソッドは通常、特定の機能を実装するために設計されるため、極端に大きなものや小さなものが混在することは少ない。第二に、小規模メソッドでの変化率の不安定性を回避できる。例えば、10行のメソッドに2行追加した場合、変化率は20\%となるが、100行のメソッドに2行追加した場合、変化率は2\%となる。このように、変化率を用いると小規模なメソッドでは値が極端に大きくなり、予測モデルにノイズをもたらす可能性がある。第三に、実際の作業負荷との対応である。「2行の追加」と「50行の追加」では、明らかに後者の方がレビュイーとレビュアーの双方にとって作業負荷が高く、欠陥発生率が高くなる傾向にある。変化量はこうした実際の作業負荷を直接的に反映する。

\paragraph{コミット単位の変更メトリクス}
コミット単位では、一つのコミット全体での変更の影響範囲や性質を捉えるため、以下の変化率を特徴量として用いる。

\begin{itemize}
    \item 変更されたファイル数
    \begin{itemize}
        \item 1つのコミットで変更されたファイルの総数
    \end{itemize}
    \item 追加行数の割合
    \begin{itemize}
        \item 変更前の総行数に対する追加されたコード行数の割合
    \end{itemize}
    \item 削除行数の割合
    \begin{itemize}
        \item 変更前の総行数に対する削除されたコード行数の割合
    \end{itemize}
    \item 1ファイル当たりの平均行数
    \begin{itemize}
        \item 変更対象となったファイルの平均規模
    \end{itemize}
\end{itemize}

これらのメトリクスで変化率を採用する理論的根拠は以下の通りである。第一に、変更規模の多様性への対応である。コミットには、単一のファイルのみを変更する小規模なものから、数十のファイルを変更する大規模なものまで、多様な規模が存在する。変化率を用いることで、異なる規模のコミット間での比較が可能になる。第二に、ファイルに対する影響度を測定できる。追加行数の割合や削除行数の割合は、ファイルサイズに対してどの程度の変更が加えられたかを示し、大規模な機能追加やリファクタリングを示唆する指標となる。第三に、予測基準のバランスが向上する。変化量のみを用いると、大規模なコミットほど欠陥修正コミットであると判定されやすくなるが、変化率を用いることで、小規模だが重要な欠陥の混入や修正を検出しやすくなる。

メソッド単位の変更メトリクスは、変更されたメソッド自体の特性を捉える。例えば、あるメソッドの循環的複雑度が5から15に増加した場合、そのメソッド内部の制御構造が複雑化したことを示す。一方、コミット単位の変更メトリクスは、同じコミットで変更された他のコードの特性も捉える。例えば、変更されたファイル数が多い場合、その変更が複数のモジュールに影響を与えていることを示す。

これらのメトリクスを組み合わせることで、コード変更をミクロとマクロの両面から多角的に評価できる。メソッド単位のメトリクスが局所的な変更の性質を捉え、コミット単位のメトリクスが変更の全体的な影響範囲を捉えることで、より精度の高い欠陥予測が可能になる。