本研究では、Ferencらが構築したBugHunter Datasetを基盤として使用する。このデータセットは、GitHubでホストされている15のJavaプロジェクトから自動的に収集されたバグ情報と、各コミットにおけるソースコード要素（ファイル、クラス、メソッド）のメトリクスを含んでいる。

BugHunterデータセットの特徴は、従来の研究が特定のリリースバージョンにおける全てのソースコード要素を収集していたのに対し、バグ混入コミットとバグ修正コミットという、バグの存在を特定できる最も狭い期間におけるコードの状態を捉えている点である。これにより、バグが混入した時点と修正された時点でのコードメトリクスの変化を分析できる。

\paragraph{対象プロジェクトの選定}
有意性検定で帰無仮説が棄却されない問題を回避するため、BugHunterデータセットに含まれる15のプロジェクトの中から、データセットのレコード数が多いプロジェクトを優先的に選定する。

データセットの構築にはSZZアルゴリズムが用いられているため、解決済みのバグレポートの数とデータセットのレコード数の大きさには相関関係がある。そのため、解決済みのバグレポート数を基準として、データセットの相対的な大きさを推測できる。この基準に基づき、解決済みのバグレポート数が多い上位5つのプロジェクトを対象として選定した。

\begin{table}[ht]
\centering
\caption{各プロジェクトのバグレポート数}
\begin{tabular}{|l|r|}
\hline
プロジェクト & バグレポート数 \\
\hline
Elasticsearch & 4,287 \\
Hazelcast & 3,762 \\
Netty & 2,207 \\
OrientDB & 1,272 \\
Neo4j & 1,152 \\
\hline
\end{tabular}
\end{table}

Elasticsearchは、分散検索・分析エンジンであり、大規模なログデータやテキストデータの検索に広く使用されている。
Hazelcastは、インメモリデータグリッドを提供する分散コンピューティングプラットフォームである。
Nettyは、高性能な非同期イベント駆動型のネットワークアプリケーションフレームワークである。
OrientDBは、マルチモデルデータベースであり、グラフデータベースとドキュメントデータベースの機能を併せ持つ。
Neo4jは、グラフデータベースの代表的な実装の一つであり、ソーシャルネットワーク分析や推薦システムなど、関係性を重視するアプリケーションで広く使用されている。

これらのプロジェクトは、いずれもJavaで記述されており、GitHubでホストされている活発なOSSプロジェクトである。ドメインも検索エンジン、分散システム、ネットワークフレームワーク、データベースと多岐にわたり、異なる開発特性を持つ。このような多様性により、提案手法が特定のプロジェクトタイプに依存せず、広範なソフトウェアシステムに適用可能であることを検証できる。

\paragraph{正解ラベルの定義}
本研究では、メソッドレベルでの欠陥予測を行うため、各メソッドに含まれるバグの数を二値化して正解ラベルとする。具体的には、バグの数が0のメソッドを「バグなし」クラス、バグの数が1以上のメソッドを「バグあり」クラスに分類する。この二値分類により、ランダムフォレストのような分類アルゴリズムを適用できる形式にデータを整形する。

\paragraph{データの前処理}
第一に、値が全て同じであるカラムを削除する。これらのカラムは予測に寄与しないため、モデルの複雑性を低減するために除外する。

第二に、メソッドの識別子をベクトルに変換する。メソッド名やクラス名といった識別子は、そのままでは機械学習モデルに入力できないため、トークン分割などの手法を用いて数値ベクトルに変換する。

\paragraph{使用するレコード数の上限}
交差検証時の評価指標の安定化を図るため、各プロジェクトのデータセットから抽出するデータポイント数の上限を5,000件とする。当初は3,000件を上限としていたが、この設定では交差検証のフェーズごとにF1スコアが大きく変動し、最悪と最良のフェーズを比較すると0.1前後の誤差が生じていた。データポイント数を5,000件に増やすことで、この変動を抑制し、より安定した性能評価が可能になった。ただし、この変動は完全には解消されておらず、データの特性に起因する本質的な課題として残っている。

各プロジェクトのデータセットから、利用可能なデータが5,000件以下の場合は全データを使用し、5,000件を超える場合は最初の5,000件を使用する。データセット内のレコードは必ずしも時系列順に並んでいるわけではないが、同一メソッドの複数のバージョン（バグ混入時と修正時）が含まれており、これらの情報を用いて変化量を計算することが可能である。