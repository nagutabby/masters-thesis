実際の開発現場では、レビューに使えるリソースは限られている。本節では、少ないレビュー労力で欠陥発見数を最大化する手法を提案する。

\paragraph{従来手法の問題点}
従来のレビュー優先度付け手法では、欠陥予測モデルが予測したクラスの値と変更行数に基づいてコミットを順位付けし、上位からレビューを行うアプローチが一般的であった\cite{kamei2013}。しかし、この手法には2つの課題がある。

第一に、レビュー労力の計算が不正確である。既存手法では変更行数のみでレビュー労力を計算しているが、実際のレビュー労力は変更の複雑度や影響範囲にも依存する。例えば、10個のファイルに分散した100行の変更は、1個のファイルに集中した100行の変更よりもレビュー労力が大きい。これは、複数ファイルにまたがる変更では、ファイル間の整合性確認やモジュール境界の理解に追加の労力を要するためである。

第二に、レビュー労力の制約設定が非現実的である。従来手法では全コミットのレビュー労力の和を総労力として設定する場合が多いが、数千行の変更を含む巨大なコミットが存在する場合、この設定は実施の開発の流れを反映しない。実際の開発現場では、レビューに使える労力には実質的な上限があり、巨大なコミットは分割されるか別の品質保証プロセスが適用される。

\paragraph{レビュー対象の優先順位付け}
本研究では、レビュー対象の選択をナップサック問題として定式化する。この定式化により、従来の単純な順位付けでは扱えない制約条件を明示的に組み込める。

レビュー対象コミットの選択は、以下の特性を持つ。
\begin{itemize}
    \item レビューに費やせる労力（制約条件）の範囲内で
    \item 各コミットのレビューに必要な労力（コスト）を考慮しながら
    \item 欠陥発見期待値（価値）の合計を最大化する
\end{itemize}

したがって、レビュー対象コミットの選択は、「容量上限のある袋に価値と重さを持つ複数のアイテムを入れるとき、総重量が容量を超えないように総価値を最大化すること」であり、ナップサック問題に置き換えられる。

レビュー待ちの各コミット $i$（$i = 1, 2, ..., N$）を選択するか否かを二値変数 $x_i \in \{0, 1\}$ で表す。コミット $i$ のレビュー労力を $W_i$、欠陥混入確率を $V_i = \hat{y}_i$、レビューに使える総労力を $C_{total}$ とすると、以下の最適化問題となる。

\begin{align}
\text{maximize} \quad & \sum_{i=1}^{N} V_i x_i \\
\text{subject to} \quad & \sum_{i=1}^{N} W_i x_i \leq C_{total} \\
& x_i \in \{0, 1\}
\end{align}

この定式化により、制約条件と目的関数を明示的に表現し、最適化理論の枠組みでレビュー対象コミットの選択を扱える。

\paragraph{レビュー労力の計算}
レビュー労力 $W_i$ は、変更の量的側面と構造的側面の両方を考慮して計算する。

まず、基本的な要素を定義する。コミット $i$ におけるコードの変更行数 $C_i$ は、追加行数 $LA_i$ と削除行数 $LD_i$ の合計である。

\[
C_i = LA_i + LD_i
\]

変更ファイル数 $N_i$ は、コミット $i$ で変更されたファイルの総数である。

変更の広がり $H_i$ は、情報理論のエントロピーにより定量化する。各ファイル $k$ が変更全体に占める割合を $p_k$ とすると、

\[
p_k = \frac{\text{file}_k \text{の変更行数}}{\text{全変更行数}}
\]

\[
H_i = -\sum_{k=1}^{n_i} p_k \log_2 p_k
\]

ここで、$n_i$ はコミット $i$ で変更されたファイル数である。エントロピーを用いる理由は、単純な平均値では捉えられない変更の分散度を定量化できるためである。全ての変更が1個のファイルに集中している場合はエントロピーが最小となり、複数のファイルに均等に分散している場合はエントロピーが最大となる。

エントロピーの値はファイル数に依存するため、異なるファイル数を持つコミット間で比較するには正規化が必要である。エントロピーの最大値は $\log_2 n_i$（変更された全てのファイルに変更が均等に分散しているとき）であることから、以下のように正規化する。

\[
\bar{H}_i = \frac{H_i}{\log_2 n_i}
\]

これら3つの要素を組み合わせてベース労力を計算する。変更行数 $C_i$ に対して、変更の複雑度や広がり（$N_i$ と $\bar{H}_i$）を乗算係数として適用する。

\[
E_i = C_i \times N_i^{\bar{H}_i}
\]

この式の意図は以下の通りである。変更ファイル数 $N_i$ を指数の底、正規化されたエントロピー $\bar{H}_i$ を指数とすることで、変更が複数のファイルに分散しているほど労力が増加する。例えば、10個のファイルに変更が均等に分散している場合（$\bar{H}_i = 1$）は $10^1 = 10$ 倍、1個のファイルに変更が集中している場合（$\bar{H}_i = 0$）は $N_i^0 = 1$ 倍となる。

実際のデータセットには数千行の変更を含む巨大なコミットが存在し、ベース労力 $E_i$ の分布が極端に歪む。この問題を解決するため、対数変換を適用する。

\[
W_i = \ln(E_i + 1)
\]

対数変換により、大きな値の増加率を抑制しながら小さな値の相対的な違いを保持できる。これにより、巨大なコミットの影響を緩和し、中小規模のコミットも適切に評価できる。

\paragraph{貪欲法による求解}
ナップサック問題を解くため、本研究では貪欲法を採用する。動的計画法は最適解を求められるが、計算量が $O(NC_{total})$ であり、容量 $C_{total}$ が大きい場合に実用的ではない。実験において、動的計画法を実装したプログラムを実行したところ、プログラムがメモリ不足により終了してしまった。一方、貪欲法は計算量が $O(N \log N)$ であり、容量に依存せず実用的な時間で解を得られる。

貪欲法では、各コミット $i$ の密度 $D_i$（単位労力あたりの欠陥発見期待値）を計算し、密度の高い順に選択する。

\[
D_i = \frac{V_i}{W_i} = \frac{\hat{y}_i}{\ln(E_i + 1)}
\]

アルゴリズムは以下の通りである。

\begin{enumerate}
    \item 全コミットについて密度 $D_i$ を計算する
    \item 密度の降順にコミットをソートする
    \item 累積労力 $W_{\text{total}} = 0$ とする
    \item ソートされた順にコミットを選択し、以下を実行する：
    \begin{itemize}
        \item $W_{\text{total}} + W_i \leq C_{total}$ であれば、コミット $i$ をレビュー対象に追加し、$W_{\text{total}} \leftarrow W_{\text{total}} + W_i$ とする
        \item そうでなければ、コミット $i$ をスキップする
    \end{itemize}
    \item 累積労力が容量を超えるまで、または全コミットを検討するまで繰り返す
\end{enumerate}

\paragraph{レビュー労力の上限設定}
ナップサックの容量 $C_{total}$ は、現実的な制約を反映する必要がある。本研究では、労力が小さい順に並べたときの上位80\%のコミットの労力の和を $C_{total}$ とする。

\begin{enumerate}
    \item 全コミットをレビュー労力 $W_i$ の昇順にソートする
    \item 上位80\%のコミットを選択する
    \item 選択されたコミットのレビュー労力の和を $C_{total}$ とする
\end{enumerate}

この設定により、極端に大きな労力を要する上位20\%のコミットを除外し、実際の開発現場におけるレビュー労力の制約を反映する。80\%というしきい値は実験的に決定されたものであり、プロジェクトの特性に応じて調整可能である。

\paragraph{評価方法}
提案手法の効果を評価するため、レビュー労力に対する欠陥発見数の累積曲線を描画し、分析する。横軸に投入したレビュー労力、縦軸に発見した欠陥数をプロットする。

提案手法では、密度の高い順にコミットを選択してレビューする。各コミットをレビューするごとに、累積レビュー労力と累積発見欠陥数を記録し曲線を描く。比較対象として、ベースラインモデル（変更メトリクスを追加する前のモデル）の予測確率を用いて同様に貪欲法を適用する。

提案手法がベースライン手法よりも左上に位置する曲線を描く場合、同じレビュー労力でより多くの欠陥を発見できることを意味し、実際のレビューにおいて、提案した特徴量が欠陥発見に役立つ可能性があると示唆される。