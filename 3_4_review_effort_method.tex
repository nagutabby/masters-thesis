\paragraph{従来手法の問題点}
従来のレビュー優先度付け手法では、欠陥予測モデルが出力したバグ混入確率に基づいてコミットを順位付けし、上位からレビューを行うアプローチが一般的であった。Kameiらの研究では、レビュー労力を「変更された行の総数」として計算し、総労力の一定割合（例えば20\%）を使用してレビューできるコミット数を評価している。

しかし、この手法には重要な単純化が含まれている。具体的には、レビュー労力を変更行数のみで計算しているため、変更の複雑さや影響範囲の広さが考慮されていない。実際のレビュー労力は、変更されたファイル数や変更の分散度といった要因にも依存する。例えば、10個のファイルに分散した100行の変更は、1個のファイルに集中した100行の変更よりもレビュー労力が大きいと考えられる。

さらに重要な問題として、従来手法では「レビューに必要な総労力」を全コミットのレビュー労力の和として設定している場合が多い。しかし、極端に大きなレビュー労力を要するコミット（例えば、数千行の変更を含むコミット）が存在する場合、この設定は現実的ではない。実際の開発現場では、レビューに使える労力には上限があり、その上限を超える巨大なコミットは分割されるか、別の品質保証プロセスが適用される。

\paragraph{ナップサック問題への定式化}
レビュー対象コミットの選択問題は、以下の特性を持つ。
\begin{itemize}
    \item 限られたレビュー労力（制約条件）の範囲内で
    \item 各コミットのレビューに必要な労力（コスト）を考慮しながら
    \item バグ発見期待値（価値）の合計を最大化する
\end{itemize}

この構造は、容量制約のある袋（ナップサック）に、価値と重さを持つ複数のアイテムを入れるとき、総重量が容量を超えないように総価値を最大化する組み合わせを求めるナップサック問題と同型である。本研究では、この対応関係を利用し、レビュー対象の選択をナップサック問題として定式化する。

レビュー待ちの各コミット $i$（$i = 1, 2, ..., N$）を選択するか否かを二値変数 $x_i \in \{0, 1\}$ で表す。コミット $i$ のレビュー労力を $W_i$、バグ混入確率（バグ発見期待値）を $V_i = \hat{y}_i$、レビューに使える総労力を $C_{total}$ とすると、以下の最適化問題となる。

\begin{align}
\text{maximize} \quad & \sum_{i=1}^{N} V_i x_i \\
\text{subject to} \quad & \sum_{i=1}^{N} W_i x_i \leq C_{total} \\
& x_i \in \{0, 1\}
\end{align}

ここで、$x_i$ は二値変数であり、コミット $i$ をレビューする場合は $x_i = 1$、レビューしない場合は $x_i = 0$ となる。

この定式化により、制約条件と目的関数を同時に扱う最適化問題として、レビュー対象の選択を数学的に表現できる。

\paragraph{レビュー労力の計算式}
レビュー労力 $W_i$ は、コードの変更量だけでなく、変更の複雑さも考慮する必要がある。例えば、100行の変更であっても、1つのファイルに集中している場合と10個のファイルに分散している場合では、後者の方がレビュー労力が大きい。これは、ファイル間の関係性の理解や、変更の影響範囲の把握に追加の認知的負荷が必要となるためである。

このような複雑さを数値化するため、本研究では以下の3つの要素を組み合わせる。

\begin{itemize}
    \item コードの変更行数 $C_i$: コミット $i$ における追加行数と削除行数の合計
\end{itemize}

\[
C_i = LA_i + LD_i
\]

ここで、$LA_i$ は追加されたコード行数、$LD_i$ は削除されたコード行数である。
\begin{itemize}
    \item 変更ファイル数 $N_i$: コミット $i$ で変更されたファイルの総数
    \item 変更の広がり $H_i$: コミット $i$ における変更の分散度を表す指標
\end{itemize}

各ファイルが変更全体に占める割合を $p_k$ とすると、変更の広がりは以下の式で計算される。

\[
H_i = -\sum_{k=1}^{n_i} p_k \log_2 p_k
\]

ここで、$n_i$ はコミット $i$ で変更されたファイル数、$p_k$ はファイル $k$ が変更全体に占める割合である。

\[
p_k = \frac{\text{file}_k \text{の変更行数}}{\text{全変更行数}}
\]

変更の広がりの値はファイル数に依存するため、異なるファイル数を持つコミット間で比較するには正規化が必要である。変更の広がりの最大値は $\log_2 n_i$（全てのファイルに均等に変更が分散している場合）であることから、この最大値で除算することで0から1の範囲に正規化できる。

\[
H_i^{\text{norm}} = \frac{H_i}{\log_2 n_i}
\]

この正規化により、ファイル数が異なるコミット間での比較が可能になる。

次に、これら3つの要素を組み合わせてベース労力を計算する。変更の規模（$C_i$）に対して、変更の複雑さ（$N_i$ と $H_i^{\text{norm}}$）を乗算係数として適用する設計を採用する。ここで、変更ファイル数 $N_i$ を指数の底、正規化された変更の広がり $H_i^{\text{norm}}$ を指数として用いることで、変更が複数のファイルに分散しているほど、また分散の度合いが大きいほど、労力が増加する関数となる。

\[
E_{\text{raw}, i} = C_i \times N_i^{H_i^{\text{norm}}}
\]

例えば、10個のファイルに均等に分散した変更（$H_i^{\text{norm}} \approx 1$）では $N_i^1 = 10$ 倍の係数が適用されるが、1個のファイルに集中した変更（$H_i^{\text{norm}} \approx 0$）では $N_i^0 = 1$ 倍となり、変更行数のみが労力として計上される。

実際のデータセットには、数千行の変更を含む巨大なコミットが存在する場合がある。このような外れ値が存在すると、ベース労力 $E_{\text{raw}, i}$ の分布が極端に歪み、中小規模のコミットの労力が相対的に無視できるほど小さくなってしまう。この問題を解決するため、対数変換を適用する。

\[
W_i = E_{\text{adj}, i} = \ln(E_{\text{raw}, i} + 1)
\]

対数変換により、大きな値の増加率を抑制しながら、小さな値の相対的な違いを保持できる。これにより、巨大なコミットの影響を緩和し、中小規模のコミットも適切に評価できる。$+1$ は $E_{\text{raw}, i} = 0$ の場合にも対応するための処理である。

\paragraph{貪欲法}
ナップサック問題を解くため、本研究では貪欲法を採用する。動的計画法は最適解を求められるが、計算量が $O(NC_{total})$ であり、容量 $C_{total}$ が大きい場合に実用的ではない。実験では、動的計画法の実装がメモリ不足により終了した。一方、貪欲法は計算量が $O(N \log N)$ であり、容量に依存せず実用的な時間で解を得られる。

貪欲法では、各アイテムを「単位重量あたりの価値（密度）」の順に並べ、密度が高いものから順に選択する。レビュー対象選択では、単位労力あたりのバグ発見期待値が高いコミットを優先することで、限られた労力で効率的にバグを発見できる。

各コミット $i$ の密度 $D_i$ を以下のように定義する。

\[
D_i = \frac{V_i}{W_i} = \frac{\hat{y}_i}{E_{\text{adj}, i}}
\]

ここで、$\hat{y}_i$ はモデルが予測したコミット $i$ のバグ混入確率、$E_{\text{adj}, i}$ はコミット $i$ の補正済みレビュー労力である。

貪欲法のアルゴリズムは以下の通りである。

\begin{enumerate}
    \item 全てのコミットについて密度 $D_i$ を計算する
    \item 密度の降順にコミットをソートする
    \item 累積労力 $W_{\text{累積}} = 0$ とする
    \item ソートされた順にコミットを選択し、以下を実行する：
    \begin{itemize}
        \item $W_{\text{累積}} + W_i \leq C_{total}$ であれば、コミット $i$ をレビュー対象に追加し、$W_{\text{累積}} \leftarrow W_{\text{累積}} + W_i$ とする
        \item そうでなければ、コミット $i$ をスキップする
    \end{itemize}
    \item 累積労力が容量を超えるまで、または全てのコミットを検討するまで繰り返す
\end{enumerate}

\paragraph{レビューに使える総労力}
ナップサックの容量 $C_{total}$（レビューに使える総労力）は、現実的な制約を反映する必要がある。全コミットの労力の和を $C_{total}$ とする素朴な設定では、極端に大きな労力を要するコミット（例えば、数千行の変更を含むコミット）が存在する場合に不適切である。実際の開発現場では、巨大なコミットは分割されるか、別の品質保証プロセスが適用されるため、レビューに使える労力には実質的な上限が存在する。

この現実を反映するため、本研究では労力が小さい順に並べた上位80\%のコミットの労力の和を $C_{total}$ とする。これにより、極端に大きな労力を要する上位20\%のコミットを除外し、現実的なレビュー労力の制約をモデル化する。

具体的な手順は以下の通りである。

\begin{enumerate}
    \item 全コミットをレビュー労力 $W_i$ の昇順にソートする
    \item 上位80\%のコミット（レビュー労力が小さい方から80\%）を選択する
    \item 選択されたコミットのレビュー労力の和を $C_{total}$ とする
\end{enumerate}

\[
C_{total} = \sum_{i \in S_{80\%}} W_i
\]

ここで、$S_{80\%}$ は労力の小さい順に並べた上位80\%のコミットの集合である。80\%というしきい値は実験的に決定されたものであり、プロジェクトの特性に応じて調整可能である。

\paragraph{レビュー労力に対する欠陥発見数の分析}
提案手法の効果を評価するため、レビュー労力を考慮したレビューを実施する状況を想定し、レビュー労力に対する欠陥発見数の累積積み上げグラフを描画し、分析する。これは、横軸に投入したレビュー労力、縦軸に発見した欠陥数をプロットしたグラフである。

提案手法では、密度の高い順にコミットを選択してレビューする。各コミットをレビューするごとに、累積レビュー労力と累積発見バグ数を記録し、曲線を描く。

比較対象として、ベースラインモデル（新たな特徴量を追加する前のモデル）を用いる。ベースラインモデルの予測確率 $\hat{y}_i^{\text{baseline}}$ を用いて密度を計算し、同様に貪欲法を適用する。

提案手法がベースライン手法よりも左上に位置する曲線を描く場合、同じレビュー労力でより多くのバグを発見できることを意味し、提案した特徴量の有効性が実証される。