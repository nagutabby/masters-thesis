実際の開発現場では、レビューに費やせる労力は少ない。本節では、少ないレビュー労力でより多くの欠陥を検出するための手法を提案する。

\paragraph{従来手法の問題点}
従来のレビュー優先度付け手法では、欠陥予測モデルの予測値（0あるいは1）と変更行数に基づいてレビュー対象のコミットを順位付けし、上位のコミットから順にレビューを行う。\cite{kamei2013}。しかし、この手法には課題が2つある。

まず、レビュー労力の推定方法が不正確である。既存手法では変更行数のみからレビュー労力を計算しているが、実際のレビュー労力は変更の複雑度にも依存する。例えば、10個のファイルに分散した100行の変更は、1個のファイルに集中した100行の変更よりもレビュー労力が大きい。なぜなら、変更が複数のファイルにまたがる場合、ファイル間の整合性を確認したり、モジュール同士の関係性を理解したりするために、より多くの労力が必要になるためである。

次に、レビュー労力の制約の設定が不適切である。従来手法では全てのコミットのレビュー労力の和が総労力として設定されているが、数千行の変更を含む巨大なコミットが存在する場合、この設定はレビューの実態を反映しない。なぜなら、実際の開発現場では、レビューに使える労力には実質的な上限があり、巨大なコミットは分割されることが多いためである。

\paragraph{レビュー対象の優先順位付け}
本研究では、レビュー対象の選択を組み合わせ最適化問題として扱う。これにより、従来の順位付け手法では扱えない制約条件を組み込める。

レビュー対象コミットの選択は、以下の特性を持つ。

\begin{itemize}
    \item レビューに費やせる労力（制約条件）の範囲内で
    \item 各コミットのレビューに必要な労力（コスト）を考慮しながら
    \item 欠陥発見期待値（価値）の合計を最大化する
\end{itemize}

したがって、レビュー対象コミットの選択は、「容量上限のある袋に価値と重さを持つ複数のアイテムを入れるとき、総重量が容量を超えないように総価値を最大化すること」であり、組み合わせ最適化問題に置き換えられる。このことから、レビュー対象コミットの選択を、限られたリソース（総労力）の中で欠陥発見の期待値を最大化する問題として考える。

具体的には、レビューを待つ各コミットに対して、レビューを実施するか否かの二値の意思決定を行う。この際、選択された全てのコミットのレビュー労力の合計が、あらかじめ設定した総労力の上限を超えないという制約条件を設ける。この制約の下で、選択されたコミットに含まれる欠陥混入確率（期待値）の総和が最大となるような組み合わせを特定することを目指す。

これにより、単純な順位付けでは考慮が難しい「少ない労力でいかに多くの欠陥混入リスクをカバーするか」というリソース配分の問題を、組み合わせ最適化問題として扱うことができるようになる。

\paragraph{レビュー労力の計算}
変更の規模と複雑度を考慮した上でレビュー労力$W_i$を計算する。

まず、コミット$i$におけるコードの変更行数$C_i$を、追加行数$LA_i$と削除行数$LD_i$の合計として定義する。次に、変更の広がり$H_i$を、以下の情報理論のエントロピーにより定量化する。

$$H_i = -\sum_{k=1}^{n_i} p_k \log_2 p_k$$

ここで、$n_i$はコミット$i$で変更されたファイル数であり、$p_k$は全ての変更行数に対する各ファイル$k$の変更行数の割合である。このエントロピーを$\log_2 n_i$で割ることで正規化し、正規化された変更の広がり$\bar{H}_i$を得る。

これらを用いて、補正済みレビュー労力$W_i$を次のように算出する。

$$W_i = \log_2(C_i \times N_i^{\bar{H}_i} + 1)$$

この対数変換により、巨大なコミットの影響が緩和され、中小規模のコミットも適切に評価できるようになる。

最後に、各コミットのレビューの優先順位を決定する指標として、単位労力あたりの欠陥混入確率を表す密度$D_i$を求める。

$$D_i = \frac{\hat{y}_i}{W_i}$$

\paragraph{貪欲法による求解}
組み合わせ最適化問題を解くため、本研究では貪欲法を採用する。動的計画法は最適解を求められるが、計算量が$O(NC_{total})$であり、容量$C_{total}$が大きい場合は実用的ではない。一方、貪欲法は計算量が$O(N \log N)$であり、容量に依存せず比較的短い時間で解を得られる。

貪欲法では、各コミット$i$の密度$D_i$（単位労力あたりの欠陥発見期待値）を計算し、密度の高い順にコミットを選択する。アルゴリズムは以下の通りである。

\begin{enumerate}
    \item 全コミットについて密度$D_i$を計算する
    \item 密度の降順にコミットをソートする
    \item 累積労力$W_{\text{total}} = 0$とする
    \item ソートされた順にコミットを選択し、以下を実行する：
    \begin{itemize}
        \item $W_{\text{total}} + W_i \leq C_{total}$であれば、コミット$i$をレビュー対象に追加し、$W_{\text{total}} \leftarrow W_{\text{total}} + W_i$とする
        \item そうでなければ、コミット$i$をスキップする
    \end{itemize}
    \item 累積労力が容量を超えるまで、または全てのコミットを検討するまで繰り返す
\end{enumerate}

\paragraph{レビュー労力の上限設定}
実際にレビューに費やせる労力を考慮した上で、容量$C_{total}$を設定する必要がある。本研究では、労力が小さい順に並べたときの上位80\%のコミットの労力の和を$C_{total}$とする。

\begin{enumerate}
    \item 全コミットをレビュー労力$W_i$の昇順にソートする
    \item 上位80\%のコミットを選択する
    \item 選択されたコミットのレビュー労力の和を$C_{total}$とする
\end{enumerate}

この設定により、レビュー労力が非常に大きいコミットを除外することで、実際の開発現場におけるレビュー労力の制約を反映する。80\%というしきい値は実験的に決定したものであり、プロジェクトの特性に応じて変更できる。

\paragraph{評価方法}
レビュー労力に対する欠陥発見数の累積曲線を用いて、提案手法の効果を評価する。この累積曲線は、横軸に「レビューに費やした労力」を配置し、縦軸に「発見した欠陥の数」を配置したものである。

提案手法では、密度の高い順にコミットを選択してレビューする。各コミットをレビューするごとに、レビューに費やした労力の合計と発見した欠陥の数の合計を記録し曲線を描く。比較対象として、ベースラインモデル（変更メトリクスを追加する前のモデル）の予測確率を用いて同様に貪欲法を適用する。

提案手法がベースライン手法よりも左上に位置する曲線を描く場合、同じレビュー労力でより多くの欠陥を発見できることを意味し、実際のレビューにおいて、提案した特徴量が欠陥発見に役立つ可能性があると示唆される。