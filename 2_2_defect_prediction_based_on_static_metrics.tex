静的コードメトリクスはソースコードの構造的特徴を定量化する。代表的なメトリクスとして、複雑度メトリクス、規模メトリクス、結合度・凝集度メトリクスがある。

McCabe\cite{mccabe1976}が提案した循環的複雑度は、プログラムの制御フローの複雑さを測定する。これは制御フローグラフにおける独立したパスの数として定義され、$V(G) = E - N + 2P$で計算される。循環的複雑度が高いほど、コードの理解が困難になり、テストすべきパスが増加するため、欠陥混入リスクが高まる。

規模メトリクスは、コードの量的な大きさを測定する。最も基本的なものはLOC（Lines of Code）であり、多くの研究でコードサイズと欠陥数の正の相関が報告されている\cite{fenton1999}。これは、コード量が増加するほど、実装すべき機能が増え、複雑性が高まるためと考えられる。

オブジェクト指向プログラムに対しては、ChidamberとKemererが提案したCKメトリクスが広く用いられる\cite{chidamber1994}。CBO（Coupling Between Objects）は、あるクラスが他のクラスに依存している度合いを示し、結合度が高いほど変更の影響範囲が広がり欠陥が混入しやすい。RFC（Response For Class）は、クラスが呼び出す可能性のあるメソッドの総数を示し、クラスの複雑性を反映する。LCOM（Lack of Cohesion of Methods）は、クラス内のメソッド間の凝集性の欠如を測定し、設計の品質を評価する。

これらの静的メトリクスは、コードの構造的問題を捉える上で有効であることが実証されている。しかし、静的メトリクスには本質的な限界がある。ある時点でのコードのスナップショットのみを分析するため、コードがどのように変化してきたか、どの程度の頻度で変更されているかといった動的な情報を捉えられない。変更の頻度やパターンは静的メトリクスよりも欠陥混入との関連性が高いことが知られており\cite{graves2000}、静的メトリクスだけでは予測精度に限界がある。