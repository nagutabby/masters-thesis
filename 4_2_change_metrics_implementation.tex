3.2節で定義した変更メトリクスを実際のデータセットに適用するため、以下の実装を行う。

\paragraph{メソッド単位の変更メトリクスの計算}
メソッド単位の変更メトリクスとして、コード行数の変化量、トークン数の変化量、循環的複雑度の変化量を算出する。これらは、同一メソッドのバグ混入時とその1つ前のコミットの値の差分として計算される。

具体的には、BugHunterデータセットに含まれる各メソッドについて、バグ混入コミット（または修正コミット）における値と、その直前のコミットにおける値を取得し、以下の計算を行う。

\begin{itemize}
    \item コード行数の変化量 = 現在のコミットのコード行数 - 直前のコミットのコード行数
    \item トークン数の変化量 = 現在のコミットのトークン数 - 直前のコミットのトークン数
    \item 循環的複雑度の変化量 = 現在のコミットの循環的複雑度 - 直前のコミットの循環的複雑度
\end{itemize}

これらの変化量は、メソッドがどの程度変更されたかを直接的に表現する指標となる。

\paragraph{コミット単位の変更メトリクスの計算}
コミット単位の変更メトリクスとして、変更されたファイル数（NF）、追加行数の割合（LA/LT）、削除行数の割合（LD/LT）、1ファイル当たりの平均行数（LT/NF）を生成する。これらは、BugHunterデータセットに含まれるコミット情報から以下のように計算される。

\begin{itemize}
    \item 変更されたファイル数（NF）: コミットで変更されたファイルの総数
    \item 追加行数の割合（LA/LT）: $\frac{\text{追加行数}}{\text{変更前の総行数}}$
    \item 削除行数の割合（LD/LT）: $\frac{\text{削除行数}}{\text{変更前の総行数}}$
    \item 1ファイル当たりの平均行数（LT/NF）: $\frac{\text{変更対象ファイルの総行数}}{\text{変更ファイル数}}$
\end{itemize}

これらの変化率ベースのメトリクスは、コミット全体での変更の影響範囲や性質を捉える。

\paragraph{メソッドの操作タイプのラベル付与}
各メソッドに対して、そのメソッドが追加、変更、削除のいずれの操作を受けたかを示すラベルを付与する。これらの操作タイプは、バグ混入コミットあるいはバグ修正コミットと、その直前のコミットを比較することで判定される。

\begin{itemize}
    \item 追加（Add）
    \begin{itemize}
        \item 直前のコミットには存在せず、当該コミットで新たに追加されたメソッド
    \end{itemize}
    \item 変更（Modify）
    \begin{itemize}
        \item 直前のコミットと当該コミットの両方に存在し、内容が変更されたメソッド
    \end{itemize}
    \item 削除（Delete）
    \begin{itemize}
        \item 直前のコミットには存在したが、当該コミットで削除されたメソッド
    \end{itemize}
\end{itemize}

これらのラベルは、カテゴリカル変数として扱い、One-Hotエンコーディングを用いて数値ベクトルに変換する。例えば、「追加」は [1, 0, 0]、「変更」は [0, 1, 0]、「削除」は [0, 0, 1] のようにエンコードされる。

\paragraph{メソッド識別子の処理}
メソッドの完全修飾名（例: org.elasticsearch.index.fielddata.plain.GeoPointDoubleArrayAtomicFieldData\$Empty.<init>()V）は、そのままでは機械学習モデルに入力できないため、トークン分割を行う。

具体的には、以下の手順で処理する。

第一に、正規表現を用いてメソッドシグネチャからパッケージ名、クラス名、メソッド名を抽出する。

第二に、パッケージ名を.で分割し、各部分をトークンとする。例えば、"org.elasticsearch.index"は["org", "elasticsearch", "index"]に分割される。

第三に、クラス名を\$で分割し、各部分をキャメルケース分割する。例えば、"GeoPointDoubleArrayAtomicFieldData"は["Geo", "Point", "Double", "Array", "Atomic", "Field", "Data"]に分割される。

第四に、メソッド名をスネークケース（\_や-）で分割した後、さらにキャメルケース分割する。ただし、<init>や<clinit>などの特殊なメソッド名は"constructor"というトークンに変換する。

第五に、全てのトークンを小文字に変換する。

さらに、"java"、"util"、"get"、"set"などのJava言語における一般的な単語や、最小トークン長（3文字）未満のトークンをストップワードとして除外する。これにより、メソッドやクラスの本質的な意味を表す有用なトークンのみが抽出される。

抽出されたトークンは、語彙辞書を用いて数値インデックスに変換され、さらにベクトル表現に変換される。この処理により、メソッドが属するパッケージやクラスの名前、メソッド名自体が持つ意味的な情報を特徴量として活用できる。

\paragraph{特徴量の統合}
最終的に、以下の特徴量を統合してモデルの入力とする。

\begin{itemize}
    \item BugHunterデータセットに元々含まれるコードメトリクス
    \item メソッド単位の変更メトリクス（変化量）
    \item コミット単位の変更メトリクス（変化率）
    \item メソッドの操作タイプ（One-Hotエンコーディング）
    \item メソッド識別子のトークンベクトル
\end{itemize}

これらを組み合わせることで、コードの静的な性質、時系列変化、操作の種類、意味的な情報を包括的に捉えた特徴量セットを構築する。