3.2節で定義した変更メトリクスを実際のデータセットに適用するため、以下の実装を行う。

\paragraph{メソッド単位の変更メトリクスの計算}
メソッド単位の変更メトリクスとして、コード行数の変化量、トークン数の変化量、循環的複雑度の変化量を算出する。これらは、同一メソッドの欠陥混入時あるいは欠陥修正時とその直前のコミットの値の差分として計算される。

具体的には、BugHunterデータセットに含まれる各メソッドについて、欠陥混入コミット（または欠陥修正コミット）における値と、その直前のコミットにおける値を取得し、以下の計算を行う。

\begin{itemize}
    \item コード行数の変化量 = 現在のコミットにおけるコード行数 - 直前のコミットにおけるコード行数
    \item トークン数の変化量 = 現在のコミットにおけるトークン数 - 直前のコミットにおけるトークン数
    \item 循環的複雑度の変化量 = 現在のコミットにおける循環的複雑度 - 直前のコミットにおける循環的複雑度
\end{itemize}

これらのメソッド単位の変更メトリクスは、メソッドがどの程度変更されたかを表現する指標となる。

\paragraph{コミット単位の変更メトリクスの計算}
コミット単位の変更メトリクスとして、変更されたファイル数、コードの追加行数、コードの削除行数、変更の広がりを生成する。これらは、BugHunterデータセットに含まれるコミット情報から以下のように計算される。

\begin{itemize}
    \item 変更されたファイル数: 現在のコミットと直前のコミットの間の変更されたファイル数
    \item コードの追加行数: 現在のコミットと直前のコミットの間のコードの追加行数
    \item コードの削除行数: 現在のコミットと直前のコミットの間のコードの削除行数
    \item 変更の広がり: $\bar{H}_i$
\end{itemize}

これらのコミット単位の変更メトリクスは、コミット全体での変更の影響範囲や性質を捉える。

\paragraph{メソッドの操作タイプのラベル付与}
メソッドの操作タイプ（追加、変更、削除）は、欠陥混入リスクと密接に関連している。新規追加されたメソッドは既存コードとの統合時に予期しない相互作用を引き起こす可能性があり、既存メソッドの変更は意図しない副作用を生む可能性がある。先行研究において、新規追加コードは既存コードと比較して欠陥密度が高い傾向があることが示されている。

各メソッドに対して、追加、変更、削除のいずれの操作が行われたかを示すラベルを付与する。これらの操作タイプは、欠陥混入コミットあるいは欠陥修正コミットと、その直前のコミットを比較することで判定される。

\begin{itemize}
    \item 追加: 直前のコミットには存在せず、そのコミットで新たに追加されたメソッド
    \item 変更: 直前のコミットとそのコミットの両方に存在し、内容が変更されたメソッド
    \item 削除: 直前のコミットには存在したが、そのコミットで削除されたメソッド
\end{itemize}

これらのラベルは、カテゴリカル変数として扱い、One-Hotエンコーディングを用いて数値ベクトルに変換する。例えば、「追加」は [1, 0, 0]、「変更」は [0, 1, 0]、「削除」は [0, 0, 1] のようにエンコードされる。

\paragraph{メソッド識別子の処理}
メソッドの完全修飾名を特徴量として利用する理由は、識別子に含まれる類似性に関する特徴が欠陥の傾向を反映するためである。メソッド名やクラス名には機能を示す単語が含まれ、例えば"parse"、"serialize"、"validate"といった単語を含むメソッドは、入力検証やデータ変換に関わるため、エッジケースの処理ミスによる欠陥が発生しやすい。また、パッケージ構造も重要な情報を提供し、特定のパッケージ（例えば、ネットワーク処理やデータベース接続）に属するメソッドは、外部リソースとの相互作用に起因する欠陥が発生しやすい。

メソッドの完全修飾名をそのまま一意な特徴量として扱うと、メソッド間のテキストの類似性を捉えられない。例えば、`getUserName()`と`getUserAge()`は、どちらも「get」と「user」という共通要素を持ち、ユーザー情報を取得するという類似した機能を持つが、完全修飾名全体を独立したカテゴリーとして扱うと、この類似性を認識できない。さらに、訓練データに存在しない新しいメソッド名に対しては、全く予測ができなくなる。

この問題を解決するため、メソッド識別子を構成要素に分解する。トークン分割により、`getUserName()`は["user", "name"]に、`getUserAge()`は["user", "age"]に分解され、両者が「user」という共通トークンを持つことを認識できる。これにより、モデルは「userに関連するメソッド」という抽象的な特徴を学習でき、訓練データに存在しない`getUserEmail()`のような新しいメソッドに対しても、["user", "email"]というトークンから適切に予測できるようになる。このトークン分割では以下の処理を実行する。

\begin{enumerate}
    \item 正規表現を用いてメソッドの完全修飾名からパッケージ名、クラス名、メソッド名を抽出する
    \item パッケージ名を.で分割し、各部分をトークンとする
    \item クラス名を\$で分割し、各部分をキャメルケース分割する（例: "UserManager" → ["User", "Manager"]）
    \item メソッド名をスネークケース（\_や-）で分割した後、さらにキャメルケース分割する（例: "get\_user\_name" → ["get", "user", "name"]）
    \item <init>や<clinit>などの特殊なメソッド名は"constructor"というトークンに変換する
    \item 全てのトークンを小文字に変換する
    \item 高頻度で出現するトークンと指定文字数未満のトークンを除外する
\end{enumerate}

表\ref{tab:tokenization_example}に、実際のメソッドの完全修飾名に対するトークン分割の例を示す。

\begin{table}[ht]
\centering
\caption{JavaCodeTokenizerによるトークン分割の例}
\label{tab:tokenization_example}
\begin{tabular}{|l|p{8cm}|}
\hline
処理ステップ & 結果 \\
\hline
元のメソッドの完全修飾名 & 
\begin{tabular}{l}
com.example.user.UserManager\\.getUserName()Ljava/lang/String; \\
\end{tabular} \\
\hline
パッケージ分割 & ["com", "example", "user"] \\
\hline
クラス名のキャメルケース分割 & ["User", "Manager"] \\
\hline
メソッド名のキャメルケース分割 & ["get", "User", "Name"] \\
\hline
小文字化 & ["com", "example", "user", "user", "manager", "get", "user", "name"] \\
\hline
高頻度で出現するトークンの除去 & ["example", "user", "manager", "user", "name"] \\
\hline
重複するトークンの除去 & ["example", "user", "manager", "name"] \\
\hline
\end{tabular}
\end{table}

この例では、"com"と"get"が高頻度で出現するトークンとして除外され、"user"は複数回出現するが意味的に重要な単語として保持される。最終的に["example", "user", "manager", "name"]という、メソッドの機能を表す有用なトークンが抽出される。

表\ref{tab:tokenization_comparison}に、異なる種類のメソッドに対するトークン分割の比較例を示す。

\begin{table}[ht]
\centering
\caption{異なるメソッドタイプのトークン分割比較}
\label{tab:tokenization_comparison}
\begin{tabular}{|l|p{5cm}|p{5cm}|}
\hline
メソッドタイプ & 元のメソッド名 & 抽出されるトークン \\
\hline
データ検証 & \texttt{validateEmail()} & ["validate", "email"] \\
\hline
JSON解析 & \texttt{parseJsonData()} & ["parse", "json", "data"] \\
\hline
データベース接続 & \texttt{connectToDatabase()} & ["connect", "database"] \\
\hline
HTTP通信 & \texttt{sendHttpRequest()} & ["send", "http", "request"] \\
\hline
コンストラクター & \texttt{<init>()} & ["constructor"] \\
\hline
\end{tabular}
\end{table}

高頻度で出現するトークンとして除外される単語は、以下の通りである。

\begin{itemize}
    \item 一般的なJavaパッケージ名: "java", "util", "lang", "io", "net", "org", "com", "javax"
    \item アクセサメソッドの接頭辞: "get", "set", "is", "has"
    \item 一般的な動詞: "create", "build", "make", "run", "execute"
    \item Javaの予約語や型名: "class", "interface", "void", "int", "string"
    \item 一般的な修飾語: "impl", "default", "base", "simple", "empty"
\end{itemize}

これらのトークンは、多くのプロジェクトで頻出するため識別能力が低く、予測モデルにノイズをもたらす。例えば、"get"という単語は非常に多くのメソッドに出現するため、欠陥の有無を区別する特徴とはならない。一方、"validate"、"parser"、"socket"といった単語は、メソッドの具体的な機能を示し、欠陥予測に有用である。

抽出されたトークンは、TF-IDF（Term Frequency-Inverse Document Frequency）を用いて数値ベクトルに変換される。TF-IDFは、各トークンの重要度を、文書内での出現頻度と全文書での出現頻度の逆数の積として計算する。これにより、特定のメソッドに特徴的なトークンに高い重みが付与され、多くのメソッドに共通するトークンの重みは抑制される。この処理により、メソッドが属するパッケージやクラスの名前、メソッド名自体が持つ意味的な情報を特徴量として活用できる。

\paragraph{特徴量の統合}
最終的に、以下の特徴量を統合してモデルの入力とする。

\begin{itemize}
    \item BugHunterデータセットに元々含まれるコードメトリクス
    \item メソッド単位の変更メトリクス
    \item コミット単位の変更メトリクス
    \item メソッドの操作タイプ
    \item メソッド識別子に含まれる特徴的なトークン
\end{itemize}

これらを組み合わせることで、コードの構造の特徴、時系列変化、操作の種類、意味的な情報を包括的に捉えた特徴量セットを構築する。

\paragraph{データ前処理とメトリクス計算の実装手順}
上述した特徴量を実際のデータセットに適用するため、以下の手順でデータの前処理とメトリクスの計算を実施する。

まず、BugHunterデータセットから取得した生データに対して前処理を行う。drop\_columns.pyを用いて全ての値が0であるカラムを削除し、drop\_rows.pyを用いて分析対象外のレコード（例えば、外部ライブラリに属するメソッド）を削除する。

前処理後のデータに対して、メソッド単位の変更メトリクスを追加する。add\_method\_level\_metrics.pyを実行し、各メソッドについて欠陥混入コミットあるいは欠陥修正コミットとその直前のコミットにおけるコード行数、トークン数、循環的複雑度を取得し、これらの差分を計算する。

続いて、コミット単位の変更メトリクスを追加する。add\_commit\_level\_metrics.pyを実行し、各コミットについて変更されたファイル数、コードの追加行数、コードの削除行数、変更の広がりを計算する。これらのメトリクスは、GitリポジトリからGitPythonライブラリを用いてコミット間の差分を取得し算出する。変更の広がりについては、Hassanの手法\cite{hassan2009}に基づき、情報理論のエントロピーを用いて変更の分散度を定量化する。

これらのプログラムは順次実行され、各ステップの出力が次のステップの入力となる。具体的には、drop\_columns.py → drop\_rows.py → add\_method\_level\_metrics.py → add\_commit\_level\_metrics.pyの順に実行することで、最終的なデータセットが構築される。これらのプログラムを含むリポジトリは、実験結果を再現するために公開されている\cite{replication_package}。
