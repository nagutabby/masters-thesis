3.4節で定義したナップサック問題アプローチに基づき、各コミットのレビュー労力を計算する方法を実装する。本節では、レビュー労力の計算式とその実装について述べる。

\paragraph{レビュー労力の計算式}
各コミット $i$ のレビュー労力 $W_i$ を計算するため、以下の要素を考慮する。

\textbf{コードの変更行数 $C_i$}: コミット $i$ における追加行数と削除行数の合計。

\[
C_i = LA_i + LD_i
\]

ここで、$LA_i$ は追加されたコード行数、$LD_i$ は削除されたコード行数である。

\textbf{変更ファイル数 $N_i$}: コミット $i$ で変更されたファイルの総数。

\textbf{変更の広がり $H_i$}: コミット $i$ における変更の広がり。

\[
H_i = -\sum_{k=1}^{n_i} p_k \log_2 p_k
\]

ここで、$n_i$ はコミット $i$ で変更されたファイル数、$p_k$ はファイル $k$ が変更全体に占める割合である。

\[
p_k = \frac{\text{file}_k \text{の変更行数}}{\text{全変更行数}}
\]

変更の広がりを正規化するため、以下の式を用いる。

\[
H_i^{\text{norm}} = \frac{H_i}{\log_2 n_i}
\]

この正規化により、変更の広がりは0から1の範囲に収まり、ファイル数が異なるコミット間での比較が可能になる。

これらの要素を組み合わせて、ベース労力 $E_{\text{raw}, i}$ を以下のように計算する。

\[
E_{\text{raw}, i} = C_i \times N_i^{H_i^{\text{norm}}}
\]

この式は、変更の規模（コードの変更行数）と、変更の複雑さ（変更ファイル数と変更の広がり）の両方を考慮している。変更ファイル数が多いほど、また変更の広がりが大きい（変更が複数のファイルに分散している）ほど、レビュー労力が増加する。

次に、極端に大きな値の影響を緩和するため、対数変換を適用する。

\[
W_i = E_{\text{adj}, i} = \ln(E_{\text{raw}, i} + 1)
\]

数千行の変更を含む巨大なコミットが存在する場合、ベース労力が極端に大きくなり、他のコミットの労力が相対的に無視できるほど小さくなってしまう。対数変換により、この影響を緩和し、中小規模のコミットも適切に評価できる。

\paragraph{レビュー総労力の設定}
ナップサックの容量 $C_{total}$（レビューに使える総労力）を以下の手順で設定する。

\begin{enumerate}
    \item 全コミットをレビュー労力 $W_i$ の昇順にソートする
    \item 上位80\%のコミット（レビュー労力が小さい方から80\%）を選択する
    \item 選択されたコミットのレビュー労力の和を $C_{total}$ とする
\end{enumerate}

\[
C_{total} = \sum_{i \in S_{80\%}} W_i
\]

ここで、$S_{80\%}$ は労力の小さい順に並べた上位80\%のコミットの集合である。

この設定により、極端に大きな労力を要するコミット（上位20\%）の影響を除外し、より現実的なレビュー労力の制約をモデル化できる。80\%というしきい値は、実験的に決定されたものであり、プロジェクトの特性に応じて調整可能である。

\paragraph{密度の計算}
各コミット $i$ の密度 $D_i$ を以下のように定義する。

\[
D_i = \frac{V_i}{W_i} = \frac{\hat{y}_i}{E_{\text{adj}, i}}
\]

ここで、$\hat{y}_i$ はモデルが予測したコミット $i$ のバグ混入確率、$E_{\text{adj}, i}$ はコミット $i$ の補正済みレビュー労力である。

密度は、単位労力あたりのバグ発見期待値を表し、レビュー対象の優先順位付けに用いられる。密度が高いコミットほど、少ない労力で多くのバグを発見できる可能性が高い。

\paragraph{データセットへの適用}
BugHunterデータセットに含まれる各コミットについて、上記の計算式を適用してレビュー労力を算出する。具体的には、各コミットの追加行数 $LA_i$、削除行数 $LD_i$、変更ファイル数 $N_i$、各ファイルの変更行数を取得し、コードの変更行数 $C_i$、変更の広がり $H_i$、正規化後の変更の広がり $H_i^{\text{norm}}$、ベース労力 $E_{\text{raw}, i}$、補正済み労力 $W_i$ を順次計算する。

これらの値は、レビュー対象選択アルゴリズムの入力として使用される。